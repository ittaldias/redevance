# -*- coding: utf-8 -*-
"""Algo_B.2.3_Traitement_Preliminaire.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1FHVS_BacYm0kKIww1Nhc3RKLl8owgukV
"""

# Fonction pour convertir un modèle en expression régulière
def pattern_to_regex(pattern):
    # Remplacer # par .*, + par [a-zA-Z] et - par [0-9]
    regex = pattern.replace('#', '.*').replace('+', '[a-zA-Z]').replace('-', '[0-9]')
    # Ajouter les délimiteurs de début et de fin
    regex = '^' + regex + '$'
    return regex

def trouver_pattern(x, pattern_list):
    for pattern in pattern_list:
        regex = pattern_to_regex(pattern)
        if re.match(regex, x):
            return True
    return False

def nbre_centre_francais(list):
    rep = 0
    for x in list:
      if x in ['PARI', 'AIX', 'BRST', 'REIM', 'BORD']:
        rep +=1
    return rep

def utile_inutile(element, pattern_list, eu_nord, eu_sud):
    # Fonction pour trouver une valeur valide dans les colonnes multiples
    def get_valid_value(element, columns):
        for col in columns:
            if col in element and not pd.isna(element[col]) and element[col] != "":
                return element[col]
        return None

    call_sign_value = get_valid_value(element, ["callSign_realise", "callSign_final", "callSign_prevu"])
    PLN_active_value = get_valid_value(element, ["PLN_activerealise", "PLN_activefinal", "PLN_activeprevu"])
    PLN_annule_value = get_valid_value(element, ["PLN_annulerealise", "PLN_annulefinal", "PLN_annuleprevu"])
    centre_traverse_value = get_valid_value(element, ["centretraversérealise", "centretraverséfinal", "centretraverséprevu"])
    dep_value = get_valid_value(element, ["deprealise", "depfinal", "depprevu"])
    arr_value = get_valid_value(element, ["arrrealise", "arrfinal", "arrprevu"])

    if trouver_pattern(call_sign_value, pattern_list):
        return "FICT"
    if PLN_active_value == "1":
        return "UTI"
    elif PLN_annule_value == "1":
        return "CNL"
    elif nbre_centre_francais(centre_traverse_value) >= 2:
        return "2SLF"
    elif dep_value == arr_value:
        return "CIRC"
    elif dep_value in eu_nord and dep_value in eu_sud:
        return "NORD"
    elif dep_value in eu_sud and dep_value in eu_nord:
        return "SUD"
    return "UTI"

def traitement_utile_inutile(df):
    df['utile_inutile'] = df.apply(lambda x: utile_inutile(x, INDICATIF_FICTIF, EUROPE_NORD, EUROPE_SUD), axis=1)
    return df